<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Crosser</title>
  <style>
    body {
      margin: 0;
      background: #0b0f1a;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      background: #111827;
      border: 2px solid #3b82f6;
      image-rendering: pixelated;
    }
    .hint {
      position: fixed;
      bottom: 12px;
      font-size: 14px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <canvas id="game" width="400" height="400"></canvas>
  <div class="hint">Arrow keys to move Â· Go as far as you can</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const TILE = 40;
    const COLS = 10;
    const VIEW_ROWS = 10;

    let cameraOffset = 0;
    let score = 0;
    let bestY = 0;

    const robot = {
      x: 4,
      y: 0,
    };

    const cars = [];

    function spawnCars(rowY) {
      for (let i = 0; i < 3; i++) {
        cars.push({
          y: rowY,
          x: Math.random() * COLS,
          speed: (Math.random() * 0.03 + 0.02) * (rowY % 2 === 0 ? 1 : -1),
        });
      }
    }

    function resetGame() {
      robot.x = 4;
      robot.y = 0;
      cameraOffset = 0;
      score = 0;
      bestY = 0;
      cars.length = 0;
      for (let i = 1; i < 20; i += 2) spawnCars(i);
    }

    resetGame();

    function drawRobot() {
      ctx.fillStyle = '#22d3ee';
      const drawY = canvas.height - (robot.y - cameraOffset + 1) * TILE;
      ctx.fillRect(robot.x * TILE + 8, drawY + 8, 24, 24);

      ctx.fillStyle = '#0f172a';
      ctx.fillRect(robot.x * TILE + 14, drawY + 14, 4, 4);
      ctx.fillRect(robot.x * TILE + 22, drawY + 14, 4, 4);
    }

    function drawCars() {
      ctx.fillStyle = '#ef4444';
      cars.forEach(car => {
        const drawY = canvas.height - (car.y - cameraOffset + 1) * TILE;
        if (drawY > -TILE && drawY < canvas.height) {
          ctx.fillRect(car.x * TILE, drawY + 6, TILE, TILE - 12);
        }
      });
    }

    function updateCars() {
      cars.forEach(car => {
        car.x += car.speed;
        if (car.speed > 0 && car.x > COLS) car.x = -1;
        if (car.speed < 0 && car.x < -1) car.x = COLS;
      });
    }

    function checkCollision() {
      return cars.some(car => (
        Math.floor(car.x) === robot.x && car.y === robot.y
      ));
    }

    function updateCamera() {
      if (robot.y - cameraOffset > VIEW_ROWS - 3) {
        cameraOffset++;
        score++;
        spawnCars(cameraOffset + VIEW_ROWS + 1);
      }
    }

    function drawGrid() {
      ctx.strokeStyle = '#1f2933';
      for (let y = 0; y < VIEW_ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          ctx.strokeRect(x * TILE, canvas.height - (y + 1) * TILE, TILE, TILE);
        }
      }
    }

    function drawHUD() {
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '14px system-ui';
      ctx.fillText(`Score: ${score}`, 10, 20);
    }

    function update() {
      updateCars();
      updateCamera();

      if (checkCollision()) {
        resetGame();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawCars();
      drawRobot();
      drawHUD();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowUp') robot.y++;
      if (e.key === 'ArrowDown' && robot.y > 0) robot.y--;
      if (e.key === 'ArrowLeft' && robot.x > 0) robot.x--;
      if (e.key === 'ArrowRight' && robot.x < COLS - 1) robot.x++;
    });

    loop();
  </script>
</body>
</html>
